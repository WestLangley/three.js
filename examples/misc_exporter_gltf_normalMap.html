<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - exporter - gltf - normalMap</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - exporter - gltf - normalMap<br/><br/>
			<button id="export_objects">Export Objects</button><br/>
			<br/><br/>
			<label><input id="option_trs" name="trs" type="checkbox"/>TRS</label>
			<label><input id="option_visible" name="visible" type="checkbox" checked="checked"/>Only Visible</label>
			<label><input id="option_drawrange" name="visible" type="checkbox" checked="checked"/>Truncate drawRange</label><br/>
			<label><input id="option_binary" name="visible" type="checkbox">Binary (<code>.glb</code>)</label>
			<label><input id="option_maxsize" name="maxSize" type="number" value="4096" min="2" max="8192" step="1"> Max texture size</label>
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { GLTFExporter } from './jsm/exporters/GLTFExporter.js';

			//

			function exportGLTF( input ) {

				const gltfExporter = new GLTFExporter();

				const options = {
					trs: document.getElementById( 'option_trs' ).checked,
					onlyVisible: document.getElementById( 'option_visible' ).checked,
					truncateDrawRange: document.getElementById( 'option_drawrange' ).checked,
					binary: document.getElementById( 'option_binary' ).checked,
					maxTextureSize: Number( document.getElementById( 'option_maxsize' ).value ) || Infinity // To prevent NaN value
				};
				gltfExporter.parse( input, function ( result ) {

					if ( result instanceof ArrayBuffer ) {

						saveArrayBuffer( result, 'scene.glb' );

					} else {

						const output = JSON.stringify( result, null, 2 );
						console.log( output );
						saveString( output, 'scene.gltf' );

					}

				}, options );

			}

			document.getElementById( 'export_objects' ).addEventListener( 'click', function () {

				exportGLTF( [ mesh1, mesh2, axes ] );

			} );

			const link = document.createElement( 'a' );
			link.style.display = 'none';
			document.body.appendChild( link ); // Firefox workaround, see #6594

			function save( blob, filename ) {

				link.href = URL.createObjectURL( blob );
				link.download = filename;
				link.click();

				// URL.revokeObjectURL( url ); breaks Firefox...

			}

			function saveString( text, filename ) {

				save( new Blob( [ text ], { type: 'text/plain' } ), filename );

			}


			function saveArrayBuffer( buffer, filename ) {

				save( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );

			}

			//

			let container;

			let camera, scene, renderer;
			let mesh1, mesh2, axes;

			init();
			render();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;

				renderer.outputEncoding = THREE.sRGBEncoding;

				container.appendChild( renderer.domElement );

				scene = new THREE.Scene();
				scene.name = 'Scene';

				axes = new THREE.AxesHelper( 10 ); // for orientaton reference
				scene.add( axes );

				// camera
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 0, 150 );
				camera.name = "PerspectiveCamera";
				scene.add( camera );

				// controls
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 100;
				controls.maxDistance = 200;

				// lights
				const light = new THREE.DirectionalLight( 0xffffff, 1 );
				light.position.set( 0, 1, 1 );
				light.name = 'DirectionalLight';
				scene.add( light );

				const light2 = new THREE.DirectionalLight( 0xffffff, 1 ); // for back-sided objects
				light2.position.set( 0, 1, - 1 );
				light2.name = 'DirectionalLight2';
				scene.add( light2 );

				// geometry1 - three.js convention: uv (0,0) bottom left
				const geometry1 = new THREE.PlaneGeometry( 50, 50 );

				// geometry2 - glTF convention: uv (0,0) top left
				const geometry2 = new THREE.PlaneGeometry( 50, 50 );
				geometry2.setAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( [ 0, 0, 1, 0, 0, 1, 1, 1 ] ), 2 ) );

				// textures
				const normalMapOpenGL = new THREE.TextureLoader().load( 'textures/NormalMapOpenGL.png', render );
				const normalMapDirectX = new THREE.TextureLoader().load( 'textures/NormalMapDirectX.png', render );

				// material
				const material = new THREE.MeshStandardMaterial( {
					color: 0x202040,
					metalness: 0,
					roughness: 0.3,
					normalMap: null,
					normalScale: new THREE.Vector2( 0.5, 0.5 ),
					side: THREE.DoubleSide
				} );

				// pick one
				// ---------------------------------------------------
				const GEOMETRY = geometry1; // geometry1 or geometry2
				// ---------------------------------------------------

				// mesh1
				mesh1 = new THREE.Mesh( GEOMETRY, material.clone() );
				mesh1.position.set( - 30, 0, 0 );

				mesh1.material.normalMap = normalMapOpenGL;
				//mesh1.material.normalMap.flipY = false; // default true
				//mesh1.material.normalScale.y *= - 1; // exporter ignores negative normalScale.y

				mesh1.name = "Mesh1";
				scene.add( mesh1 );

				// mesh2
				mesh2 = new THREE.Mesh( GEOMETRY, material.clone() );
				mesh2.position.set( 30, 0, 0 );

				mesh2.material.normalMap = normalMapDirectX;
				//mesh2.material.normalMap.flipY = false; // default true
				mesh2.material.normalScale.y *= - 1; // exporter ignores negative normalScale.y

				mesh2.name = "Mesh2";
				scene.add( mesh2 );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
